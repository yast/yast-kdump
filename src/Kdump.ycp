/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/Kdump.ycp
 * Package:	Configuration of kdump
 * Summary:	Kdump settings, input and output functions
 * Authors:	Jozef Uhliarik <juhliarik@suse.com>
 *
 * $Id: Kdump.ycp 27914 2006-02-13 14:32:08Z locilka $
 *
 * Representation of the configuration of kdump.
 * Input and output routines.
 */

{

module "Kdump";
textdomain "kdump";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "BootCommon";
//import "Storage";
import "Map";
import "Bootloader";
import "Service";
import "Popup";
import "Arch";
import "Mode";
import "BootCommon";
import "Map";
import "ProductControl";
import "ProductFeatures";
import "PackagesProposal";
import "FileUtils";
import "String";
import "Directory";

/**
 * Prototypes
 */
global boolean GetModified();

global void SetModified();

/**
 * Data was modified?
 */
global boolean modified = false;

/**
 * kdump config file
 */

string kdump_file = "/etc/sysconfig/kdump";


/**
 */
global boolean proposal_valid = false;

/**
 * List of available partiotions
 * with known partition
 *
 * list <string>
 */
global list <string> available_partitions =[];

/**
 * true if propose was called
 */
global boolean propose_called = false;

/**
 * List of available partiotions
 * without filesystem or with uknown
 *
 * list <string>
 */
global list <string> uknown_fs_partitions =[];

/**
 * Total available memory [MB]
 * 
 *
 * integer
 */
global integer total_memory =0;

/** Boolean option indicates that "crashkernel" includes
 *  several ranges
 *
 * boolean true if there are several ranges (>1)
 */
global boolean crashkernel_list_ranges = false;


/** 
 *  list of packages for installation
 */
global list<string> kdump_packages =[];

/**
 * Number of cpus
 * 
 * integer
 */
integer number_of_cpus = 1;

/**
 * kernel version (uname -r)
 * 
 * string
 */
string kernel_version = "";


/**
 * Position actual boot section in BootCommon::sections list
 * it is relevant only if XEN boot section is used
 *
 * integer
 */
integer section_pos = -1;


/** Boolean option indicates kernel parameter
 * "crashkernel"
 *
 * boolean true if kernel parameter is set
 */
global boolean crashkernel_param = false;

/**
 * String option indicates value of kernel parameter
 * "crashkernel"
 *
 * string value of kernel parameter
 */
global string crashkernel_param_value = "";

/**
 * Boolean option indicates add kernel param
 * "crashkernel"
 *
 * boolean true if kernel parameter will be add
 */
global boolean add_crashkernel_param = false;


/**
 * String option for alocate of memory for boot param
 * "crashkernel"
 *
 * string value number of alocate memory
 */
global string alocated_memory = "0";

/**
 * Boolean option indicates that Import()
 * was called and data was proposed
 *
 * boolean true if import was called with data
 */

global boolean import_called = false;


/**
 * String option identify which boot section was used
 * during boot process
 *
 * string value actual boot section
 */

global string actual_boot_section = "";


/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
global boolean write_only = false;

/**
 * Abort function
 * return boolean return true if abort
 */
global boolean() AbortFunction = nil;

/**
 * map of deafult values for options in UI
 *  
 * global map <string, string >
 */

global map <string, string > DEFAULT_CONFIG = $[
     "KDUMP_KERNELVER"              : "",
     "KDUMP_COMMANDLINE"            : "",
     "KDUMP_COMMANDLINE_APPEND"     : "",
     "KEXEC_OPTIONS"                : "",
     "KDUMP_IMMEDIATE_REBOOT"       : "yes",
     "KDUMP_COPY_KERNEL"	    : "yes",
     "KDUMP_TRANSFER"               : "",
     "KDUMP_SAVEDIR"      	    : "file:///var/crash",
     "KDUMP_KEEP_OLD_DUMPS"         : "5",
     "KDUMP_FREE_DISK_SIZE"    	    : "64",
     "KDUMP_VERBOSE"      	    : "3",
     "KDUMP_DUMPLEVEL"		    : "0",
     "KDUMP_DUMPFORMAT"		    : "compressed", //or "ELF"
     "KDUMP_SMTP_SERVER"	    : "",
     "KDUMP_SMTP_USER"		    : "",
     "KDUMP_SMTP_PASSWORD"	    : "",
     "KDUMP_NOTIFICATION_TO"	    : "",
     "KDUMP_NOTIFICATION_CC"	    : "",
];

/**
 * map <string, string > of kdump settings
 *    
 */
global map <string, string > KDUMP_SETTINGS = $[];

/**
 * Abort function
 * @return boolean return true if abort
 */
global define boolean Abort() ``{
    if(AbortFunction != nil)
    {
	return AbortFunction () == true;
    }
    return false;
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean GetModified() {
    y2debug("modified=%1",modified);
    return modified;
}


/**
 * Set data was modified
 */
global void SetModified() {
    modified = true;
    y2debug("modified=%1",modified);
}


/**
 * Compare boot section options with 
 *
 * options from running kernel
 *  @return integer return number of differences
 */

integer CmpKernelAndBootOptions (list <string> kernel_option, list <string> boot_options) {
  integer result = size(kernel_option);
  integer dif_size = size(boot_options) - size(kernel_option);
  if (dif_size < 0)
     dif_size = dif_size*(-1);
  foreach (string option, kernel_option, {
    if (contains(boot_options, option))
       result = result -1;
  });

  result = result + dif_size;
  return result;
}


/**
 * Function add into option from boot 
 * section root device and vgamode
 * 
 *  @return list <string> boot section + root and vgamode
 */


list <string> AddDeviceVgamode (map section) {
  string tmp_boot_section = tostring(section["append"]:nil);
  // adding root device
  tmp_boot_section = tmp_boot_section + " root=" + tostring(section["root"]:nil);
  tmp_boot_section = tmp_boot_section + " vga=" + tostring(section["vgamode"]:nil);
  
  return splitstring(tmp_boot_section," ");

}

/**
 * Function set permission for file.
 *
 * @return	boolean true on success
 * @param	string file name
 * @param	string permissions
 *
 * @example
 *	FileUtils::Chmod ("/etc/sysconfig/kdump", "600") -> true
 *	FileUtils::Chmod ("/tmp/doesnt_exist", "644") -> false
 */
boolean Chmod (string target, string permissions) 
{
    if (! FileUtils::Exists(target)) 
    {
	y2error ("Target %1 doesn't exist", target);
	return false;
    }

    if (! FileUtils::Exists("/bin/chmod")) 
    {
	y2error ("tool: /bin/chmod not found");
	return false;
    }

    string cmd = sformat ("/bin/chmod %1 %2", permissions, target);
    map cmd_out = (map) SCR::Execute (.target.bash_output, cmd);

    if (cmd_out["exit"]:-1 != 0) 
    {
	y2error ("Command >%1< returned %2", cmd, cmd_out);
	return false;
    }
    y2milestone("Command: %1 finish successful.", cmd);
    return true;
}

/**
 * Read actual boot section
 *
 * read kernal version and boot options
 *  @return string actual boot section
 */


string GetActualBootSection () {
  // read option from bootlaoder

  string result = "";
  string kernel_boot_options = "";
  integer min_dif_size = 1000;

  if (Mode::update())
  {
     result = Bootloader::getDefaultSection ();
     integer section_position = -1;
     foreach(map section, BootCommon::sections, 
     {
	section_position = section_position +1;
        string name = tostring(section["name"]:nil);

        if ((name == result) && (section["xen_append"]:nil != nil))
        {
	    section_pos = section_position;
	    kernel_version = "xen";
	}
     });
     return result;
  }
  // reading bootloader settings
  boolean old_progress = Progress::set (false);
  Bootloader::Read();
  Progress::set (old_progress);

  // reading kernel options
  string command = "cat /proc/cmdline";
  map options = (map)SCR::Execute (.target.bash_output, command);
  y2milestone("[kdump] (GetActualBootSection) command read boot options from kernel:  %1  output: %2",command, options);  
  
  if (options["exit"]:nil !=  0)
     return "";

  kernel_boot_options = tostring(options["stdout"]:nil);

  // reading version of kernel
  command = "uname -r";
  options = (map)SCR::Execute (.target.bash_output, command);
  y2milestone("[kdump] (GetActualBootSection) command read kernel version:  %1  output: %2",command, options);  
  
  if (options["exit"]:nil !=  0)
     return "";

  kernel_version = tostring(options["stdout"]:nil);  
  y2milestone("[kdump] (GetActualBootSection) kerne version: %1",kernel_version);

  // boot sections from bootloader
  list<map<string,any> > sects = BootCommon::sections;

  // deleting non linux sections
  sects = filter (map<string,any> s, sects, ``(
                ! haskey (s, "chainloader")));
  
  y2milestone("[kdump] (GetActualBootSection) BootCommon::sections only linux sections:  %1",sects);

  // find probably boot section, what was used during start-up
  foreach(map section, sects, {

    string image = tostring(section["image"]:nil);

    if (image != nil) {
       command = "/sbin/get_kernel_version "+image;
       options = (map)SCR::Execute (.target.bash_output, command);

       if (options["exit"]:nil ==  0) {
          string ret = tostring(options["stdout"]:nil);

          if (ret == kernel_version) {
             //Popup::Message("hura!");
             integer value = CmpKernelAndBootOptions(splitstring(kernel_boot_options," "),AddDeviceVgamode(section));
             if (value < min_dif_size) {
                min_dif_size = value;
                result = tostring(section["name"]:nil);		
             }
          } // end if (ret == kernel_version)
       } // end if (options["exit"]:nil ==  0)     
    } // end of if (image != nil)           
  }); // end of foreach(map section, sects, {

  y2milestone("[kdump] (GetActualBootSection) selected boot section :  %1",result);
  return result;

}

/**
 * get value of crashkernel option
 * from XEN boot section
 *  @param string crashkernel=64M@16M
 *  @return string value of carshkernel option
 */

string getCrashKernelValue (string crash)
{
    y2milestone("crashkernel option %1", crash);
    string result ="";
    if ((crash != "") || (crash != nil))
    {
	integer position = search(crash, "=");
	if (position != nil)
	    result = substring(crash, position+1); 
	else
	    y2error("Wrong crashkernel option!");

    }
    y2milestone("crashkernel value is %1", result);
    return result;

}

/**
 * Function check if KDUMP_SAVEDIR or
 * KDUMP_SMTP_PASSWORD include password
 *
 * @return boolean true if inlude password
 */

boolean checkPassword()
{
   if (KDUMP_SETTINGS["KDUMP_SMTP_PASSWORD"]:"" != "")
	return true;

   if ((search(KDUMP_SETTINGS["KDUMP_SAVEDIR"]:"", "file") != nil) 
      || (search(KDUMP_SETTINGS["KDUMP_SAVEDIR"]:"", "nfs") != nil)
      || (KDUMP_SETTINGS["KDUMP_SAVEDIR"]:"" == ""))
	return false;

   if (search(KDUMP_SETTINGS["KDUMP_SAVEDIR"]:"", "@") == nil)
	return false;

   list<string> temp = splitstring(KDUMP_SETTINGS["KDUMP_SAVEDIR"]:"", "@");
   string temp_1 = temp[0]:"";
   integer position = findlastof(temp_1, ":");
   if (position == nil)
	return false;

   // if there is 2 times ":" -> it means that password is defined
   // for example cifs://login:password@server....
   if (position > 6)
	return true;
   else
	return false;
}


/**
 * get alocated memory from value of crashkernel option
 * there can be several ranges -> take the first range
 *  @param string 64M@16M or 128M-:64M@16M [(reserved_memory*2)-:reserved_memory]
 *  @return string value of alocated memory (64M)
 */

string getAlocatedMemory(string crash_value)
{
   string result = "";
   string allocated = "";
   string range ="";
   if (search(crash_value,",") != nil)
   {
      list<string> ranges = splitstring(crash_value,",");
      crashkernel_list_ranges = true;
      range = ranges[0]:"";

   } else {
      range = crash_value;
   }
   y2milestone("The 1st range from crashkernel is %1", range);
   integer position =  search(range,":");
 
   if (position != nil) 
      allocated = substring(range, position+1);
   else
      allocated = range;

   result = substring(allocated,0,search(allocated,"M"));

   y2milestone("Allocated memory is %1", result);
   return result;
}

/**
 * Build crashkernel value from alocated memory
 * 
 *  @return string value of crashkernel
 */

string BuildCrashkernelValue ()
{
    // if user doesn't modified or select don't modify 
    // return readed value
    if (crashkernel_list_ranges)
	return crashkernel_param_value;

    string crash_value = "";
    crash_value = alocated_memory+"M";
    // bnc#563905 problem with offset in crashkernel
    if ((Arch::i386()) ||(Arch::x86_64()) || (Arch::ia64()) || Arch::ppc64())  {
        y2milestone("i386, x86_64, ia64 and ppc64 platforms are without offset");
    } else {
       if (Mode::normal())
          Popup::Error(_("Unsupported architecture, \"crashkernel\" was not added"));
       y2error("Unsupported platform/architecture...");
    }

    string reserved_memory = tostring(2*tointeger(alocated_memory));
    

    crash_value = reserved_memory+"M-:"+crash_value;
    y2milestone("builded crashkernel value is %1", crash_value);
    return crash_value;

}

/** bnc #439881 - Don't use extended crashkernel syntax for Xen
 * Fuction convert extended crashkernel value to old style :Y@X
 *
 * @param string - extended value of crashkernel
 * @return string - old style value
 */


string convertCrashkernelForXEN(string crash)
{
    string crash_value = "";
    if (crash != "")
    {
	crash_value = getAlocatedMemory(crash)+"M";
	
	// bnc#563905 problem with offset in crashkernel
	// bnc#585371 kdump fails to load with xen: locate_hole failed
	if ((Arch::i386()) ||(Arch::x86_64()) || Arch::ppc64())
        	crash_value = crash_value + "@16M";

    }
    y2milestone("Converting crashkernel value from: (%1) to :(%2)",crash, crash_value);
    return crash_value;
}



/**
 * Check if default boot section is Xen section
 * remember position of section (important for saving to xen_append)
 * @param string name of section
 */

define void CheckXenDefault(string act_boot_secion)
{
    if ((act_boot_secion != "") && (act_boot_secion != nil))
    {
       integer section_position = -1;
       foreach(map section, BootCommon::sections, 
       {
	    section_position = section_position +1;
            string name = tostring(section["name"]:nil);
	    string type = tostring(section["type"]:nil);

            if ((name == act_boot_secion) && (type == "xen"))
            { 
	       section_pos = section_position;
               y2milestone("default boot section is Xen...");
            }              

       });
       if (section_pos == -1)
          y2milestone("default boot section is NOT Xen...");
    }
}

/**
 * Read current kdump configuration
 * from XEN boot section
 * read kernel parameter "crashkernel"
 *  @return boolean successfull
 */


boolean ReadXenKdumpKernelParam (string act_boot_secion)
{

    string crash = "";
    if (actual_boot_section == "")
    {
	y2milestone("Actual boot section was not found");
	crashkernel_param = false;
        add_crashkernel_param = false;
    } else {
	integer section_position = -1;
        foreach(map section, BootCommon::sections, 
        {
	    section_position = section_position +1;
            string name = tostring(section["name"]:nil);

            if (name == act_boot_secion) 
            {
		crash = section["xen_append"]:"";
		section_pos = section_position;
	    }
        });
    }

    if (crash != "")
    {
	list<string> xen_append = splitstring(crash, " ");
	string crash_arg = "";

	if (size(xen_append)>1)
	{
	   foreach(string key, xen_append,
	   {
		if (search(key, "crashkernel") != nil)
		   crash_arg = key;
           });
        } else {
	   crash_arg = crash;
	}

	if (crash_arg != "")
	{
	   crashkernel_param = true;
     	   add_crashkernel_param = true;
	   crashkernel_param_value =  getCrashKernelValue(crash_arg);
           alocated_memory = getAlocatedMemory(crashkernel_param_value);
	} else {
 	   crashkernel_param = false;
           add_crashkernel_param = false;
	}
    }

    return true;
}


/**
 * Read current kdump configuration
 *
 * read kernel parameter "crashkernel"
 *  @return boolean successfull
 */

boolean ReadKdumpKernelParam () {
 
  actual_boot_section =  GetActualBootSection ();

  if (search(kernel_version, "xen") != nil)
      return ReadXenKdumpKernelParam (actual_boot_section);


  if (actual_boot_section == "")
     actual_boot_section = Bootloader::getDefaultSection ();

  string result = Bootloader::getKernelParam (actual_boot_section, "crashkernel");

  //Popup::Message(result);
  if (result == "false") {
     crashkernel_param = false;
     add_crashkernel_param = false;
  } else { 
     crashkernel_param = true;
     add_crashkernel_param = true;
  }

  crashkernel_param_value = result;
  if (result != "false")
     alocated_memory = getAlocatedMemory(crashkernel_param_value);

  return true;
}

/**
 * Propose reserved/allocated memory
 *
 * 
 *  @return boolean successfull
 */

boolean ProposeAlocatedMemory () 
{
  if (alocated_memory == "0") 
  {
     if (Arch::s390()) {
	alocated_memory = tostring(128 + (total_memory * 256) * 2.01 / 8 / 1048576);
     }
     else if ((total_memory >= 512) &&  (total_memory/1024) <2)
        alocated_memory = "64";
     else if ((total_memory/1024) >= 2)
        alocated_memory = "128";

     // bnc #431492 - UPT-LTE: /proc/vmcore is empty in kdump kerne
     if ((Arch::ppc64()) && (alocated_memory != ""))
     {
	 integer al_mem = tointeger(alocated_memory);
	 al_mem = al_mem *2;
	 alocated_memory = tostring(al_mem);
     }
     // bnc #446480 - Fine-tune kdump memory proposal
     // bnc #578590 -"out of memory" error occurs when doing kdump on machine superdome
     if ((Arch::ia64()) && (total_memory >= 1024))
     {
	 integer total_memory_gigabyte = total_memory/1024;
         if ((total_memory_gigabyte >= 1) && (total_memory_gigabyte <8))
	     alocated_memory = "256";
	 else if ((total_memory_gigabyte >= 8) && (total_memory_gigabyte <128))
	     alocated_memory = "512";
	 else if ((total_memory_gigabyte >= 128) && (total_memory_gigabyte <256))
	     alocated_memory = "768";
	 else if ((total_memory_gigabyte >= 256) && (total_memory_gigabyte <378))
	     alocated_memory = "1024";
	 else if ((total_memory_gigabyte >= 378) && (total_memory_gigabyte <512))
	     alocated_memory = "1536";
	 else if ((total_memory_gigabyte >= 512) && (total_memory_gigabyte <768))
	     alocated_memory = "2048";
	 else if (total_memory_gigabyte >= 768)
	     alocated_memory = "3072";
     }
  }
  y2milestone("[kdump] allocated memory if not set in \"crashkernel\" param: %1", alocated_memory);
  return true;
}

/**
 * Read available memory
 *
 * 
 *  @return boolean successfull
 */

boolean ReadAvailableMemory () {

  list <map> output =  (list<map>)SCR::Read(.probe.memory);
  y2milestone("[kdump] (ReadAvailableMemory) SCR::Read(.probe.memory): %1", output);

  map <any,any> resor = $[];
  list <any> temp = maplist(map mem, output,{    
    return mem["resource"]:nil;
  });
  //y2milestone("[kdump] (ReadAvailableMemory) temp: %1", temp);
  resor = tomap(temp[0]:nil);
  
  output = (list<map>)resor["phys_mem"]:nil;
  temp = maplist(map mem, output,{    
    return mem["range"]:nil;
  });
  //list <any> range = maplist(map resor["phys_mem"]:nil);
 
  //resor = (map)range;
  total_memory = tointeger(temp[0]:nil)/1048576;
  y2milestone("[kdump] (ReadAvailableMemory) total phys. memory [MB]: %1", tostring(total_memory));
  ProposeAlocatedMemory ();
  return true;
}



/**
 * Read current kdump configuration
 *
 *  @return boolean successfull
 */
boolean ReadKdumpSettings () {
    KDUMP_SETTINGS = DEFAULT_CONFIG;
    if (Arch::s390()) {
      string cmd = "lscss | egrep \"(3990|2105|3880|9343|6310|2107|1731/03|3215)\" |cut -d\" \" -f1|sed s/^/\\!/|tr \"\n\" ,|sed s/,$//";
      map cmd_out = (map) SCR::Execute (.target.bash_output, cmd);
      KDUMP_SETTINGS["KDUMP_COMMANDLINE_APPEND"] = sformat("cio_ignore=all,%1", cmd_out["stdout"]:nil);
    }
    foreach (string key,  SCR::Dir(.sysconfig.kdump), {
	string val = (string) SCR::Read(add(.sysconfig.kdump, key));
        if (val != nil) KDUMP_SETTINGS[key] = val;
    });

    map <string, string > debug_KDUMP_SETTINGS = KDUMP_SETTINGS;

    // delete KDUMP_SAVEDIR - it can include password
    debug_KDUMP_SETTINGS["KDUMP_SAVEDIR"] = "********";
    debug_KDUMP_SETTINGS["KDUMP_SMTP_PASSWORD"] = "********";
    y2milestone("-------------KDUMP_SETTINGS-------------------");  
    y2milestone("kdump configuration has been read without value \"KDUMP_SAVEDIR\" and \"KDUMP_SMTP_PASSWORD\": %1", debug_KDUMP_SETTINGS);
    y2milestone("---------------------------------------------");

    return true;
}

/**
 * Write current kdump configuration
 *
 *  @return boolean successfull
 */
boolean WriteKdumpSettings () {
    map <string, string > debug_KDUMP_SETTINGS = KDUMP_SETTINGS;
    // delete KDUMP_SAVEDIR - it can include password
    debug_KDUMP_SETTINGS["KDUMP_SAVEDIR"] = "********";
    debug_KDUMP_SETTINGS["KDUMP_SMTP_PASSWORD"] = "********";
    y2milestone("-------------KDUMP_SETTINGS-------------------");  
    y2milestone("kdump configuration for writing without value \"KDUMP_SAVEDIR\" and \"KDUMP_SMTP_PASSWORD\": %1", debug_KDUMP_SETTINGS);
    y2milestone("---------------------------------------------");

    foreach (string option_key, string option_val, KDUMP_SETTINGS, {
	SCR::Write(add(.sysconfig.kdump, option_key), option_val);
    });
    SCR::Write(.sysconfig.kdump, nil);


    if (checkPassword())
	Chmod(kdump_file, "600");
    else
	Chmod(kdump_file, "644");
    return true;
}

/**
 * Add crashkernel arg to 
 *
 *
 *
 */

boolean addCrashkernelToKexec (string crashkernel_value)
{
    if ((crashkernel_value == "") && (crashkernel_value == nil))
    {
	y2milestone("crashkernel value empty");
	return false;
    }
    // command for checking if kernel_params exist
    string cmd = sformat("ls '%1/kernel_params' |tr -d '\n'", String::Quote (Directory::vardir));
    y2milestone("Checking existing file kernel_params via command %1", cmd);

    map out = (map)WFM::Execute(.local.bash_output, cmd);

    cmd = sformat("%1/kernel_params",Directory::vardir);
    // check output
    if (out["stdout"]:"" != cmd)
    {
	y2milestone ("File kernel_params was not found, output: %1", out);
	return false;
    }

    // command for reading kernel_params
    cmd = sformat("cat '%1/kernel_params' |tr -d '\n'", String::Quote (Directory::vardir));
    y2milestone("Reading kernel arguments via command %1", cmd);
    // read data from /var/lib/YaST2/kernel_params
    out = (map)WFM::Execute(.local.bash_output, cmd);
    // check output
    if (out["exit"]:nil != 0)
    {
	y2error ("Reading kernel arguments failed, output: %1", out);
	return false;
    }

    string kernel_args = out["stdout"]:"";
    // check if kernel_params contains any data
    if (size(kernel_args) <2)
    {
	y2error ("%1/kernel_params is empty, kernel_params=%2 ", Directory::vardir, kernel_args);
	return false;
    }

    // add crashkernel value to variable
    kernel_args = kernel_args + " crashkernel=" + crashkernel_value;

    // command for updating kernel_params
    cmd = sformat("echo \"%1\" > '%2/kernel_params'", 
          kernel_args, String::Quote (Directory::vardir));
    y2milestone("Update kernel arguments via command %1", cmd);
    // read data from /var/lib/YaST2/kernel_params
    out = (map)WFM::Execute(.local.bash_output, cmd);
    // check output
    if (out["exit"]:nil != 0)
    {
	y2error ("Writining kernel arguments failed, output: %1", out);
	return false;
    }

    return true;

}

/**
 * Write kdump boot argument crashkernel
 * set kernel-kdump start at boot
 *
 *  @return boolean successfull
 */
boolean WriteKdumpBootParameter () {
  boolean result = true;
  boolean old_progress = false;
  if (Mode::installation())
  {
     Bootloader::Read();
     actual_boot_section = Bootloader::getDefaultSection ();
     CheckXenDefault(actual_boot_section);
  }

  y2milestone("Default boot section is %1", actual_boot_section);
  if (add_crashkernel_param) {

     string crash_value = "";
     if (!Mode::autoinst())
        crash_value = BuildCrashkernelValue ();

     // bnc #450132 - added check if bootloader is not installed
     if (((!crashkernel_param) || (crash_value != crashkernel_param_value)) && 
	(actual_boot_section != "") && (actual_boot_section != nil)) 
     {

	if (Mode::autoinst())
	    crash_value = crashkernel_param_value;


	if (Mode::update())
	{
	    if (search(crash_value, "@") != nil)
	    {
		list<string> tmp_crash_value = splitstring(crash_value, "@");
		crash_value = tmp_crash_value[0]:"";
		y2milestone("Delete offset crashkernel value: %1", crash_value);
	    }
	}
        // write crashkernel option to boot section
	if (section_pos == -1)
	{
            result = Bootloader::setKernelParam (actual_boot_section, "crashkernel", crash_value);
	} else {
	    BootCommon::sections[section_pos, "xen_append"]= "crashkernel="+convertCrashkernelForXEN(crash_value);
	    // added flag which means that section was changed bnc #432651
	    BootCommon::sections[section_pos, "__changed"] = true;
	    result = true;
	    y2milestone("Write boot section to XEN boot section %1", BootCommon::sections[section_pos]:nil);
	}
        old_progress = Progress::set (false);
        Bootloader::Write();
        Progress::set (old_progress);
        // Popup::Message(crash_value);
        y2milestone("[kdump] (WriteKdumpBootParameter) adding chrashkernel option with value : %1", crash_value);
        if (Mode::normal())
           Popup::Message(_("To apply changes a reboot is necessary."));

	if (Mode::installation())
	    addCrashkernelToKexec(crash_value);

        Service::Enable("boot.kdump");
        return result;
     }
     // start kernel-kdump at boot
     Service::Enable("boot.kdump");

     if (Service::Status("boot.kdump") == 0)
        Service::Restart("boot.kdump");
  } else {
    if (crashkernel_param) {
       //delete crashkernel paramter from bootloader
       result = Bootloader::setKernelParam (actual_boot_section, "crashkernel", "false");
       old_progress = Progress::set (false);
       Bootloader::Write();
       Progress::set (old_progress);
       if (Mode::normal())
          Popup::Message(_("To apply changes a reboot is necessary."));
    }
    Service::Disable("boot.kdump");
    if (Service::Status("boot.kdump") == 0)
       Service::Stop("boot.kdump");
    return result;
  }    
  return true;
}



/**
 * Read all kdump settings
 * @return true on success
 */
global boolean Read() 
{
    /* Kdump read dialog caption */
    string caption = _("Initializing kdump Configuration");
    integer steps = 4;

    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/4 */
	    _("Reading the config file..."),
            /* Progress stage 3/4 */
            _("Reading kernel boot options..."),
            /* Progress stage 4/4 */
            _("Reading available memory..."),
 
	], [
	    /* Progress step 1/4 */
	    _("Reading the config file..."),
            /* Progress step 2/4*/
            _("Reading partitions of disks..."),
            /* Progress finished 3/4*/ 
            _("Reading available memory..."),
	    /* Progress finished 4/4*/
	    Message::Finished()
	],
	""
    );

    // read database
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!ReadKdumpSettings ()) Report::Error(_("Cannot read config file /etc/sysconfig/kdump"));

   // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadKdumpKernelParam ()) Report::Error(_("Cannot read kernel boot options."));

    // read another database
    if(Abort()) return false;
    Progress::NextStep();
    /* Error message */
    if(!ReadAvailableMemory ()) Report::Error(_("Cannot read available memory."));

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    modified = false;
    return true;
}

/**
 * Update crashkernel argument during update of OS
 * @return true on success
 */

global boolean Update()
{
    y2milestone("Update kdump settings");
    ReadKdumpKernelParam ();
    WriteKdumpBootParameter ();
    return true;
}

/**
 * Write all kdump settings
 * @return true on success
 */
global boolean Write() 
{
    /* Kdump read dialog caption */
    string caption = _("Saving kdump Configuration");

    //number of stages
    integer steps = 2;
    if (Mode::installation())
    {
       boolean write_kdump = ProductFeatures::GetBooleanFeature ("globals", "enable_kdump");
       if ((write_kdump == nil) || (!write_kdump))
       {
	  y2milestone("Installation doesn't support kdump.");
          return true;
       }

    }

    if ((Mode::installation() || Mode::autoinst()) && (!add_crashkernel_param))
    {
	y2milestone("Skip writing of configuration for kdump during installation");
	return true;
    }

    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Update boot options")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Updating boot options..."),
	    /* Progress finished */
	    _("Finished")
	],
	""
    );

    // write settings
    if(Abort()) return false;
    Progress::NextStage();
    /* Error message */
    if(!WriteKdumpSettings ()) Report::Error (_("Cannot write settings."));

    // write/delete bootloader option for kernel "crashkernel"
    if(Abort()) return false;
    Progress::NextStage ();
    /* Error message */
    if(!WriteKdumpBootParameter ()) Report::Error (_("Adding crashkernel parameter to bootloader fault."));

    if(Abort()) return false;
    /* Progress finished */
    Progress::NextStage();

    if(Abort()) return false;
    return true;
}

/**
 * Adding necessary packages for installation
 *
 */

define void AddPackages()
{
    
    if (Mode::installation()) 
    {
        kdump_packages = add(kdump_packages, "kexec-tools");
	kdump_packages = add(kdump_packages, "yast2-kdump");
        if (Arch::ppc64())
            kdump_packages = add(kdump_packages, "kernel-kdump");
        else
            kdump_packages = add(kdump_packages, "kdump");
    }
}

/**
 * Propose global variables once...
 * after that remember user settings
 */

define void ProposeGlobalVars()
{
    if (!propose_called)
    {
       // propose disable kdump if PC has less than 1024MB RAM
       if (total_memory < 1024)  
	  add_crashkernel_param = false;
       else
	  add_crashkernel_param = true;

       crashkernel_param = false;
       // added defualt settings
       KDUMP_SETTINGS = DEFAULT_CONFIG;
    }
    propose_called = true;
}


/**
 * Check if user enabled kdump
 * if no deselect packages for installing
 * if yes add necessary packages for installation
 */
global define void CheckPackages()
{
    // remove duplicates
    kdump_packages = toset(kdump_packages);
    if (!add_crashkernel_param)
    {
	y2milestone("deselect packages for installation: %1", kdump_packages);
        boolean pkg_deselect = false;
        foreach (string p, kdump_packages, 
	{
		PackagesProposal::RemoveResolvables ("yast2-kdump", `package, [p]);
		pkg_deselect = true;
	});
	if (pkg_deselect)
	{
	    y2milestone("Deselected kdump packages for installation: %1", kdump_packages);
	}
    } else {
	y2milestone("select packages for installation: %1", kdump_packages);
	boolean pkg_added = false;
	foreach (string p, kdump_packages, 
	{
		PackagesProposal::AddResolvables ("yast2-kdump", `package, [p]);
		pkg_added = true;
	
	});
	if (pkg_added)
	{
	    y2milestone("Selected kdump packages for installation: %1", kdump_packages);
	}
    }
}

/**
 * Propose all kdump settings
 *
 */
global define void Propose () 
{
    y2milestone("Proposing new settings of kdump");
    // read available memory
    ReadAvailableMemory ();
    // set default values for global variables
    ProposeGlobalVars();

    // add packages for installation
    AddPackages();

    // select packages for installation
    CheckPackages();
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global define list<string> Summary () 
{
    list<string> result = [];
    result = add (result, sformat (_("Kdump status: %1"), (add_crashkernel_param ? _("enabled") :_("disabled"))));
    if (add_crashkernel_param )
    {
    	result = add (result, sformat (_("Value of crashkernel option: %1"), BuildCrashkernelValue()));
    	result = add (result, sformat (_("Dump format: %1"), KDUMP_SETTINGS["KDUMP_DUMPFORMAT"]:""));
    	result = add (result, sformat (_("Target of dumps: %1"), KDUMP_SETTINGS["KDUMP_SAVEDIR"]:""));
    	result = add (result, sformat (_("Number of dumps: %1"), KDUMP_SETTINGS["KDUMP_KEEP_OLD_DUMPS"]:""));
    }
    return result;
}

/**
 * Export kdump settings to a map
 * @return kdump settings
 */
global define map Export () 
{
    map out = $[
	    "crash_kernel" : BuildCrashkernelValue(),
	    "add_crash_kernel" :  add_crashkernel_param,
	    "general" : KDUMP_SETTINGS,
    ];

    y2milestone ("Kdump exporting settings: %1", out);
    return out;

}

/**
 * Import settings from a map
 * @param settings map of kdump settings
 * @return boolean true on success
 */
global define boolean Import (map settings) 
{
    y2milestone("Importing settings for kdump");
    crashkernel_param_value = settings["crash_kernel"]:"";
    add_crashkernel_param = settings["add_crash_kernel"]:false;
    boolean result = true;
    map <string, string > my_import_map = settings["general"]:$[];
    foreach (any key, Map::Keys(DEFAULT_CONFIG), 
    {
	string str_key = tostring(key);
    	string val = (string) my_import_map[str_key]:nil;	
    	if (val != nil) KDUMP_SETTINGS[str_key] = val;
    	if (val == nil) KDUMP_SETTINGS[str_key] = DEFAULT_CONFIG[str_key]:nil; 
    });
    if ((haskey(settings, "crash_kernel")) || (haskey(settings, "add_crash_kernel")) ||
	(size(my_import_map) > 0))
    	import_called = true;
    return result;
}

/* EOF */
}
